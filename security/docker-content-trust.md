## Docker Content Trust

When transferring data among networked systems, trust is a central concern. In particular, when communicating over an
untrusted medium such as the internet, it is critical to ensure the integrity and the publisher of all the data a system
operates on. You use the Docker Engine to push and pull images (data) to a public or private registry. Content Trust
gives you the ability to verify both the integrity and the publisher of all the data received from a registry over any
channel.

### About Docker Content Trust (DCT)

Docker Content Trust (DCT) provides the ability to use digital signatures for data sent to and received from remote
Docker registries. These signatures allow client-side or runtime verification of the integrity and publisher of specific
image tags.

Through DCT, image publishers can sign their images and image consumers can ensure that the images they pull are signed.
Publishers could be individuals or organizations manually signing their content or automated software supply chains
signing content as part of their release process.

### Image tags and DCT

An individual image record has the following identifier:

```shell script
[REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]
```

A particular image `REPOSITORY` can have multiple tags. For example, `latest` and `3.1.2` are both tags on the `mongo`
image. An image publisher can build an image and tag combination many times changing the image with each build.

DCT is associated with the `TAG` portion of an image. Each image repository has a set of keys that image publishers use
to sign an image tag. Image publishers have discretion on with tags they sign.

An image repository can contain an image with one tag that is signed and another tag that is not. Publishers can choose
to sign a specific tag or not. As a result, the content of an unsigned image tag and that of a signed image tag with the
same name may not match. For example, a publisher can push a tagged image `someimage:latest` and sign it. Later, the
same publisher can push an unsigned `someimage:latest` image. This second push replaces the last unsigned tag `latest`
but does not affect the signed `latest` version. The ability to choose which tags they can sign, allows publishers to
iterate over the unsigned version of an image before officially signing it.

Image consumers can enable DCT to ensure that images they use were signed. If a consumer enables DCT, they can only
pull, run or build with trusted images. Enabling DCT is a bit like applying a "filter" to your registry. Consumers "see"
only signed image tags and the less desirable, unsigned image tags are "invisible" to them.

To the consumer who has not enabled DCT, nothing about how they work with Docker images changes. Every images is visible
regardless of whether it is signed or not.

### Docker Content Trust Keys

Trust for an image is managed through the use of signing keys. A key set is created when an operation using DCT is first
invoked. A key set consists of the following classes of keys:
* an offline key that is the root of DCT for an image tag
* repository or tagging keys that sign tags
* server-managed keys such as the timestamp key, which provides freshness security guarantees for your repository

![DCT Keys](https://docs.docker.com/engine/security/trust/images/trust_components.png)

You should back up the root key somewhere safe. Given that it is only required to create new repositories, it is a good
idea to store it offline in hardware: [Manage keys fot DCT](https://docs.docker.com/engine/security/trust/trust_key_mng/)

### Signing images with Docker Content Trust

Within the Docker CLI we can sign and push a container image with the `docker trust` command syntax. A prerequisite for
signing an image is a Docker registry with a Notary server attached.

To sign a Docker image, you will need a delegation key pair. These keys can be generated locally using `docker trust key generate`,
generated by a CA or by UCP.

First we will add the delegation key to the local Docker trust repository (this is stored in `~/.docker/trust/`). If you
are generating delegation keys with `docker trust key generate`, the private key is automatically added to the local
trust store. If you are importing a separate key, you will need to use the `docker trust key load` command.

```shell script
$ docker trust key generate jeff
  Generating key for jeff...
  Enter passphrase for new jeff key with ID 9deed25:
  Repeat passphrase for new jeff key with ID 9deed25:
  Successfully generated and loaded private key. Corresponding public key available: /home/ubuntu/Documents/mytrustdir/jeff.pub
```

Or if you have an existing key:

```shell script
$ docker trust key load key.pem --name jeff
  Loading key from "key.pem"...
  Enter passphrase for new jeff key with ID 8ae710e:
  Repeat passphrase for new jeff key with ID 8ae710e:
  Successfully imported key from key.pem
```

Next, we will ned to add the delegation public key to the Notary server.

```shell script
$ docker trust signer add --key cert.pem jeff dtr.example.com/admin/demo
```

Finally, we will use the delegation private key to sign a particular tag and push it up to the registry.

```shell script
$ docker trust sign dtr.example.com/admin/demo:1
  Signing and pushing trust data for local image dtr.example.com/admin/demo:1, may overwrite remote trust data
  The push refers to repository [dtr.example.com/admin/demo]
  7bff100f35cb: Pushed
  1: digest: sha256:3d2e482b82608d153a374df3357c0291589a61cc194ec4a9ca2381073a17f58e size: 528
  Signing and pushing trust metadata
  Enter passphrase for signer key with ID 8ae710e:
  Successfully signed dtr.example.com/admin/demo:1
```

...